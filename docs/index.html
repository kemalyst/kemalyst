<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta id="repository-name" content="github.com/drujensen/kemalyst">
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="js/doc.js"></script>
  <title>README - github.com/drujensen/kemalyst</title>
</head>
<body>

<div id="types-list">
  <div id="search-box">
    <input type="search" id="search-input" placeholder="Search...">
  </div>

  <ul>
    <li class="current"><a href="index.html">README</a></li>
  </ul>

  <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/ActionHelper" data-name="actionhelper">
      <a href="ActionHelper.html">ActionHelper</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/FileUpload" data-name="fileupload">
      <a href="FileUpload.html">FileUpload</a>
      
    </li>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst" data-name="kemalyst">
      <a href="Kemalyst.html">Kemalyst</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Application" data-name="kemalyst::application">
      <a href="Kemalyst/Application.html">Application</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Controller" data-name="kemalyst::controller">
      <a href="Kemalyst/Controller.html">Controller</a>
      
    </li>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions" data-name="kemalyst::exceptions">
      <a href="Kemalyst/Exceptions.html">Exceptions</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions/Forbidden" data-name="kemalyst::exceptions::forbidden">
      <a href="Kemalyst/Exceptions/Forbidden.html">Forbidden</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions/RouteNotFound" data-name="kemalyst::exceptions::routenotfound">
      <a href="Kemalyst/Exceptions/RouteNotFound.html">RouteNotFound</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler" data-name="kemalyst::handler">
      <a href="Kemalyst/Handler.html">Handler</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Base" data-name="kemalyst::handler::base">
      <a href="Kemalyst/Handler/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/BasicAuth" data-name="kemalyst::handler::basicauth">
      <a href="Kemalyst/Handler/BasicAuth.html">BasicAuth</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Block" data-name="kemalyst::handler::block">
      <a href="Kemalyst/Handler/Block.html">Block</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/CORS" data-name="kemalyst::handler::cors">
      <a href="Kemalyst/Handler/CORS.html">CORS</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/CSRF" data-name="kemalyst::handler::csrf">
      <a href="Kemalyst/Handler/CSRF.html">CSRF</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Error" data-name="kemalyst::handler::error">
      <a href="Kemalyst/Handler/Error.html">Error</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Flash" data-name="kemalyst::handler::flash">
      <a href="Kemalyst/Handler/Flash.html">Flash</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Logger" data-name="kemalyst::handler::logger">
      <a href="Kemalyst/Handler/Logger.html">Logger</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Params" data-name="kemalyst::handler::params">
      <a href="Kemalyst/Handler/Params.html">Params</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Route" data-name="kemalyst::handler::route">
      <a href="Kemalyst/Handler/Route.html">Route</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Router" data-name="kemalyst::handler::router">
      <a href="Kemalyst/Handler/Router.html">Router</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Session" data-name="kemalyst::handler::session">
      <a href="Kemalyst/Handler/Session.html">Session</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Static" data-name="kemalyst::handler::static">
      <a href="Kemalyst/Handler/Static.html">Static</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Mailer" data-name="kemalyst::mailer">
      <a href="Kemalyst/Mailer.html">Mailer</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/WebSocket" data-name="kemalyst::websocket">
      <a href="Kemalyst/WebSocket.html">WebSocket</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

</div>

<div id="main-content">
<p><a href="https://travis-ci.org/drujensen/kemalyst" target="_blank"><img src="https://travis-ci.org/drujensen/kemalyst.svg?branch=master" alt="Build Status"/></a></p>

<p><a href="http://drujensen.github.io/kemalyst/" target="_blank">Documentation</a></p>

<h1>Kemalyst</h1>

<p>Kemalyst is a yarlf (yet another rails like framework) that is based on on
super fast <a href="https://github.com/sdogruyol/kemal" target="_blank">kemal</a>. The framework
leverages http handlers which are similar to Rack middleware.</p>

<p>Kemalyst follows the MVC pattern:</p>

<ul><li>Models are a simple ORM mapping and supports MySQL, PG and SQLite.</li><li>Views are handled using <a href="https://github.com/jeromegn/kilt" target="_blank">kilt</a> which support ECR (Erb like), SLang (Slim like), Crustache (Mustache like) or Temel (not sure what it's like).</li><li>Controllers are http handlers that continue the chain of handlers after the routing takes place.</li></ul></ul>

<p>Kemalyst also supports:</p>

<ul><li>WebSockets provide two way communication for webapps that need dynamic updates</li><li>Mailers render and deliver email via <a href="https://github.com/raydf/smtp.cr" target="_blank">smtp.cr</a></li><li>Jobs perform background tasks using <a href="https://github.com/mperham/sidekiq.cr" target="_blank">sidekiq.cr</a></li><li>Migrations provide ability to maintain your database schema's using <a href="https://github.com/juanedi/micrate" target="_blank">Micrate</a></li></ul></ul>

<p>Kemalyst also comes with a command line tool similar to <code>rails</code> called <code>kgen</code> to help you get started quickly.</p>

<h2>Installation</h2>

<h3>Brew</h3>

<ol><li>Install Crystal</li></ol>

<pre><code class='language-sh'>brew update
brew install crystal-lang</code></pre>

<ol><li>Install Kemalyst Generator</li></ol>

<pre><code class='language-sh'>brew tap drujensen/kgen
brew install kgen</code></pre>

<ol><li>Initialize a new Kemalyst App using <code>kgen</code></li></ol>

<pre><code class='language-sh'>kgen init app [your_app] [options]
cd [your_app]</code></pre>

<p>There are several options:</p>

<ul><li>-d [pg | mysql | sqlite] - defaults to pg</li><li>-t [slang | ecr] - defaults to slang</li><li>--deps - install dependencies quickly.  This is the same as running <code>shards install</code></li></ul></ul>

<p>This will generate a traditional web application:</p>

<ul><li>/config - The <code>database.yml</code> and <code>routes.cr</code> are here.</li><li>/lib - shards (similar to gems in rails) are installed here.</li><li>/public - Default location for html/css/js files.</li><li>/spec - all the crystal specs go here.</li><li>/src - all the source code goes here.</li></ul>

<h2>Generators</h2>

<p><code>kgen generate</code> provides several generators:</p>

<ul><li>scaffold [name] [fields]</li><li>model [name] [fields]</li><li>controller [name] [methods]</li><li>mailer [name] [fields]</li><li>job [name] [fields]</li><li>migration [name]</li></ul></ul>

<p>An example to generate scaffolding for a resource:</p>

<pre><code class='language-sh'>kgen generate scaffold Post name:string body:text draft:bool</code></pre>

<p>This will generate scaffolding for a Post:</p>

<ul><li>src/controllers/post_controller.cr</li><li>src/models/post.cr</li><li>src/views/post/*</li><li>db/migrations/[datetimestamp]_create_post.sql</li><li>spec/controllers/post_controller_spec.cr</li><li>spec/models/post_spec.cr</li><li>appends route to config/routes.cr</li><li>appends navigation to src/layouts/_nav.slang</li></ul>

<h3>Run Locally</h3>

<p>To test the app locally:</p>

<ol><li>Create a new database called <code>[your_app]</code> in the db you chose.</li><li>Run <code>export DATABASE_URL=postgres://[username]:[password]@localhost:5432/[your_app]</code>or update the database url in <code>config/database.yml</code>.</li><li>Migrate the database: <code>kgen migrate up</code>. You should see output like <code>
Migrating db, current version: 0, target: [datetimestamp]
OK   [datetimestamp]_create_shop.sql</code></li><li>Run the specs: <code>crystal spec</code></li><li>Start your app: <code>kgen watch</code></li><li>Then visit <code>http://0.0.0.0:3000</code></li></ol>

<p>Note: The <code>kgen watch</code> command uses <a href="https://github.com/samueleaton/sentry" target="_blank">Sentry</a> to watch for any changes in your source files, recompiling automatically.</p>

<p>If you don't want to use Sentry, you can compile and run manually:</p>

<ol><li>Build the app <code>crystal build --release src/[your_app].cr</code></li><li>Run with <code>./[your_app]</code></li><li>Visit <code>http://0.0.0.0:3000</code></li></ol>

<h3>Run with Docker</h3>

<p>Another option is to run using Docker.  A <code>Dockerfile</code> and <code>docker-compose.yml</code> is provided. If
you have docker setup, you can run:</p>

<pre><code class='language-sh'>docker-compose up -d
docker-compose logs -f</code></pre>

<p>Now visit the site:</p>

<pre><code class='language-sh'>open "http://localhost:3000"</code></pre>

<p>Docker Compose is running <a href="https://github.com/samueleaton/sentry" target="_blank">Sentry</a> as well so
any changes to your <code>/src</code> or <code>/config</code> will re-build and run your
application.</p>

<h3>Configure App</h3>

<p>All config settings are in the <code>/config</code> folder.  Each handler has its own
settings.  You will find the <code>database.yml</code> and <code>routes.cr</code> here.</p>

<h3>Router</h3>

<p>The router will perform a lookup based on the method and path and return the
chain of handlers you specify in the <code>/config/routes.cr</code> file.</p>

<p>You can use any of the following methods: <code>get, post, put, patch, delete, all</code></p>

<p>An example of a route would be:</p>

<pre><code class='language-crystal'>get <span class="s">&quot;/&quot;</span>,   <span class="t">DemoController</span><span class="t">::</span><span class="t">Index</span></code></pre>

<p>You can use <code>:variable</code> in the path and it will set a
context.params["variable"] to the value in the url.</p>

<pre><code class='language-crystal'>get    <span class="s">&quot;/posts/:id&quot;</span>, <span class="t">DemoController</span><span class="t">::</span><span class="t">Show</span></code></pre>

<p>You may chain multiple handlers in a route using an array:</p>

<pre><code class='language-crystal'>get <span class="s">&quot;/&quot;</span>, [ <span class="t">BasicAuth</span>.instance(<span class="s">&quot;username&quot;</span>, <span class="s">&quot;password&quot;</span>),
           <span class="t">DemoController</span><span class="t">::</span><span class="t">Index</span>.instance ]</code></pre>

<p>or add them individually in the correct order:</p>

<pre><code class='language-crystal'>get <span class="s">&quot;/&quot;</span>, <span class="t">BasicAuth</span>.instance(<span class="s">&quot;username&quot;</span>, <span class="s">&quot;password&quot;</span>)
get <span class="s">&quot;/&quot;</span>, <span class="t">DemoController</span><span class="t">::</span><span class="t">Index</span>.instance</code></pre>

<p>This is how you would configure a WebSocket Controller:</p>

<pre><code class='language-crystal'>get <span class="s">&quot;/&quot;</span>, <span class="t">ChatController</span><span class="t">::</span><span class="t">Chat</span>
get <span class="s">&quot;/&quot;</span>, <span class="t">ChatController</span><span class="t">::</span><span class="t">Index</span></code></pre>

<p>See below for more information on how to create a WebSocket Handler.</p>

<h3>Controllers</h3>

<p>The Controller inherits from HTTP::Handler which is the middleware similar to
Rack's middleware.  The handlers are chained together in a linked-list and
each will perform some action against the HTTP::Server::Context and then call
the next handler in the chain.  The router will continue this chain for a
specific route.  The final handler should return the generated response that will be
returned as the body and then the chain will unwind and perform post handling.</p>

<p>An example of a controller:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;../models/post&quot;</span>

<span class="k">module</span> <span class="t">Post</span>
  <span class="k">include</span> <span class="t">ActionHelper</span> <span class="c">#adds in helper method &quot;action&quot;</span>

  action <span class="t">Index</span> <span class="k">do</span>
    posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY created_at DESC&quot;</span>)
    html render(<span class="s">&quot;post/index.ecr&quot;</span>, <span class="s">&quot;main.ecr&quot;</span>)
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>Note: The above is shorthand for this:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;../models/post&quot;</span>

<span class="k">class</span> <span class="t">Index</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Controller</span>
  <span class="k">def</span> <span class="m">call</span>(context)
    posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY created_at DESC&quot;</span>)
    html render(<span class="s">&quot;post/index.ecr&quot;</span>, <span class="s">&quot;main.ecr&quot;</span>)
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>There are several helper macros that will set the contenttype and responses status.</p>

<pre><code class='language-crystal'>  redirect <span class="s">&quot;path&quot;</span>                       <span class="c"># redirect to path</span>
  html     <span class="s">&quot;&lt;html&gt;&lt;/html&gt;&quot;</span>, <span class="n">200</span>         <span class="c"># content type &#96;text/html&#96; with status code of 200</span>
  text     <span class="s">&quot;text&quot;</span>, <span class="n">200</span>                  <span class="c"># content type &#96;text/plain&#96; with status code of 200</span>
  json     <span class="s">&quot;&#123;&#125;&quot;</span>.to_json, <span class="n">200</span>            <span class="c"># content type &#96;application/json&#96; with status code of 200</span>
  xml      <span class="s">&quot;&#123;&#125;&quot;</span>.to_xml, <span class="n">200</span>            <span class="c"># content type &#96;application/xml&#96; with status code of 200</span></code></pre>

<p>There are two render methods that will generate a string that can be passed to the above macros:</p>

<pre><code class='language-crystal'>  render   <span class="s">&quot;filename.ecr&quot;</span>               <span class="c"># renders an .ecr template</span>
  render   <span class="s">&quot;filename.ecr&quot;</span>, <span class="s">&quot;layout.ecr&quot;</span> <span class="c"># renders an .ecr template with layout</span></code></pre>

<p>You can use the rendering engine to generate <code>html</code>, <code>json</code>, <code>xml</code> or <code>text</code>:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;../models/post&quot;</span>

<span class="k">class</span> <span class="t">Index</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Controller</span>
  <span class="k">def</span> <span class="m">call</span>(context)
    posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY created_at DESC&quot;</span>)
    json render(<span class="s">&quot;post/index.json.ecr&quot;</span>)
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<h3>Views</h3>

<p>Views are rendered using <a href="http://github.com/jeromegn/kilt" target="_blank">Kilt</a>.  Currently,
there are 4 different templating languages supported by Kilt: <code>ecr</code>, <code>mustache</code>,
<code>slang</code> and <code>temel</code>.  Kilt will select the templating engine based on the
extension of the file so <code>index.ecr</code> will render the file using the ECR
engine.</p>

<p>The render method is configured to look in the "src/views" path to keep the
controllers simple.  You may also render with a layout which will look for
this in the "src/views/layouts" directory.</p>

<pre><code class='language-crystal'>html render <span class="s">&quot;post/index.ecr&quot;</span>, <span class="s">&quot;main.ecr&quot;</span></code></pre>

<p>This will render the index.ecr template inside the main.ecr layout. All local
variables assigned in the controller are available in the templates.</p>

<p>An example <code>views/post/index.ecr</code>:</p>

<pre><code class='language-erb'>&lt;% posts.each do |post| %>
  &lt;div>
    &lt;h2>&lt;%= post.name %>&lt;/h2>
    &lt;p>&lt;%= post.body %>&lt;/p>
    &lt;p>
      &lt;a href="/posts/&lt;%= post.id %>">read&lt;/a>
      | &lt;a href="/posts/&lt;%= post.id %>/edit">edit&lt;/a> |
      &lt;a href="/posts/&lt;%= post.id %>?_method=delete" onclick="return confirm('Are you sure?');">delete&lt;/a>
    &lt;/p>
  &lt;/div>
&lt;% end %></code></pre>

<p>And an example of <code>views/layouts/main.ecr</code>:</p>

<pre><code class='language-html'>&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;title>Example Layout&lt;/title>
    &lt;link rel="stylesheet" href="/stylesheets/main.css">
  &lt;/head>
  &lt;body>
    &lt;div class="container">

      &lt;div class="row">
      &lt;% context.flash.each do |key, value| %>
        &lt;div class="alert alert-&lt;%= key %>">
          &lt;p>&lt;%= value %>&lt;/p>
        &lt;/div>
      &lt;% end %>
      &lt;/div>

      &lt;div class="row">
        &lt;div class="col-sm-12">
          &lt;%= content %>
        &lt;/div>
      &lt;/div>

    &lt;/div>
  &lt;/body>
&lt;/html></code></pre>

<p>The <code><%= content %></code> is where the template will be rendered in the layout.</p>

<p>CSRF middleware is built in.  In your forms, add the <code>csrf_tag</code> using the helper method:</p>

<pre><code class='language-erb'>&lt;form action="/demos/&lt;%= demo.id %>" method="post">
  &lt;%= csrf_tag(context) %>
  ...
&lt;/form></code></pre>

<h3>Models</h3>

<p>The models are a simple ORM mechanism that will map objects to rows in the database.  The mapping is done using several macros.</p>

<p>An example <code>models/post.cr</code></p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;kemalyst-model/adapter/pg&quot;</span>

<span class="k">class</span> <span class="t">Post</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Model</span>
  adapter pg
  field name : <span class="t">String</span>
  field body : <span class="t">Text</span>
  field published : <span class="t">Bool</span>
  timestamps
<span class="k">end</span></code></pre>

<p>The mapping will automatically create the id of type Int64.  If you include <code>timestamps</code>, a created_at and updated_at field
mapping is created that will automatically get updated for you.</p>

<p>You can override the table name:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;kemalyst-model/adapter/pg&quot;</span>

<span class="k">class</span> <span class="t">Comment</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Model</span>
  adapter pg
  table_name post_comments
  field post_id : <span class="t">Int64</span>
  field name <span class="t">String</span>
  field body : <span class="t">Text</span>
<span class="k">end</span></code></pre>

<p>You can override the <code>id</code> field:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;kemalyst-model/adapter/pg&quot;</span>

<span class="k">class</span> <span class="t">Comment</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Model</span>
  adapter pg
  primary my_id : <span class="t">Int32</span>
  ...
<span class="k">end</span></code></pre>

<p>There are several methods that are provided in the model.</p>

<ul><li>self.clear - "DELETE from table;" that will help with specs</li><li>save - Insert or update depending on if id is set</li><li>destroy(id) - "DELETE FROM table WHERE id = #{id}"</li><li>all(where) "SELECT * FROM table #{where};"</li><li>find(id) - "SELECT * FROM table WHERE id = #{id} LIMIT 1;"</li><li>find_by(field, value) - "SELECT * FROM table WHERE #{field} = #{value} LIMIT 1;"</li></ul>

<p>You can find more details at <a href="https://github.com/drujensen/kemalyst-model" target="_blank">Kemalyst Model</a></p>

<h3>WebSocket Controllers</h3>

<p>The WebSocket Controller will handle upgrading a HTTP Request to a WebSocket
Connection.</p>

<p>An example WebSocket Controller:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Chat</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">WebSocket</span>
  @sockets <span class="o">=</span> <span class="o">[]</span> <span class="k">of</span> <span class="t">HTTP</span><span class="t">::</span><span class="t">WebSocket</span>

  <span class="k">def</span> <span class="m">call</span>(socket : <span class="t">HTTP</span><span class="t">::</span><span class="t">WebSocket</span>)
    @sockets.push socket
    socket.on_message <span class="k">do</span> <span class="o">|</span>message<span class="o">|</span>
      @sockets.each <span class="k">do</span> <span class="o">|</span>a_socket<span class="o">|</span>
        a_socket.send message.to_json
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>The <code>Chat</code> class will override the <code>call</code> method that is expecting an
<code>HTTP::WebSocket</code> to be passed which it would maintain and properly handle
messages to and from each socket.</p>

<p>This class will manage an array of <code>HTTP::Websocket</code>s and configures the
<code>on_message</code> callback that will manage the messages that will be then be
passed on to all of the other sockets.</p>

<p>It's important to realize that if the request is not asking to be upgraded to
a websocket, it will call the next handler in the path.  If there is no
more handlers configured, a 404 will be returned.</p>

<p>Here is an example routing configuration:</p>

<pre><code class='language-crystal'>get <span class="s">&quot;/&quot;</span>, <span class="t">ChatController</span><span class="t">::</span><span class="t">Chat</span>
get <span class="s">&quot;/&quot;</span>, <span class="t">ChatController</span><span class="t">::</span><span class="t">Index</span></code></pre>

<p>The first one is a WebSocket Controller and the second is a standard
Controller.  If the request is not a WebSocket upgrade request, it will
pass-through and call the second one that will return the html page.</p>

<p>To see an example application, checkout
<a href="https://github.com/drujensen/chat-kemalyst" target="_blank">Chat Kemalyst</a></p>

<h3>Mailers</h3>

<p>Kemalyst provides the ability to generate mailers:</p>

<pre><code class='language-sh'>kgen g mailer Welcome email:string name:string</code></pre>

<p>This will generate the following files:</p>

<ul><li>config/mailer.yml</li><li>spec/mailers/welcome_mailer_spec.cr</li><li>src/mailers/welcome_mailer.cr</li><li>src/views/layouts/mailer.slang</li><li>src/views/mailers/welcome_mailer.slang</li></ul></ul>

<p>The mailer has the ability to set the <code>from</code>, <code>to</code>, <code>cc</code>, <code>bcc</code>, <code>subject</code> and <code>body</code>.
You may use the <code>render</code> helper to create the body of the email.</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">WelcomeMailer</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Mailer</span>
  <span class="k">def</span> <span class="m">initialize</span>
    <span class="k">super</span>
    from <span class="s">&quot;from&#64;example.com&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">deliver</span>(name: <span class="t">String</span>, email: <span class="t">String</span>)
    to name: name, email: email
    subject <span class="s">&quot;Welcome to Kemalyst&quot;</span>
    body render(<span class="s">&quot;mailers/welcome_mailer.slang&quot;</span>, <span class="s">&quot;mailer.slang&quot;</span>)
    <span class="k">super</span>()
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>To delivery a new email:</p>

<pre><code class='language-crystal'>mailer <span class="o">=</span> <span class="t">WelcomeMailer</span>.<span class="k">new</span>
mailer.deliver(name, email)</code></pre>

<p>You can deliver this in the controller but most agree this should be done in a background job.</p>

<h3>Jobs</h3>

<p>Kemalyst provides a generator for with integration user sidekiq.cr for background jobs:</p>

<pre><code class='language-sh'>kgen g job Welcome name:string email:string</code></pre>

<p>This will generate:</p>

<ul><li>config/sidekiq.cr</li><li>docker-sidekiq.yml</li><li>spec/jobs/spec_helper.cr</li><li>spec/jobs/welcome_job_spec.cr</li><li>src/jobs/welcome_job.cr</li><li>src/sidekiq.cr</li></ul></ul>

<p>Jobs are using <code>sidekiq.cr</code> for handling the background process.  Sidekiq uses <code>redis</code> to handle the queues and spins up several fibers to handle processing each job from the queue.</p>

<p>You will either need to install <code>redis</code> locally or you can use the <code>docker-sidekiq.yml</code> which is a pre-configured docker-compose file that will spin up the needed services.</p>

<p>To install redis locally and start the service:</p>

<pre><code class='language-sh'>brew install redis
brew services start redis</code></pre>

<p>Sidekiq is expecting two environment variables to be configured:</p>

<pre><code class='language-sh'>export REDIS_PROVIDER = REDIS_URL
export REDIS_URL = redis://localhost:6379</code></pre>

<p>Then you can start and watch the sidekiq service using <code>kgen</code>:</p>

<pre><code class='language-sh'>kgen sidekiq</code></pre>

<p>This will watch for any changes to the jobs and recompile and launch sidekiq.</p>

<p>Or you can compile and run the sidekiq.cr manually:</p>

<pre><code class='language-sh'>crystal build --release src/sidekiq.cr
./sidekiq</code></pre>

<p>Here is an example background job that will deliver the email we created earlier:</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;sidekiq&quot;</span>
<span class="k">require</span> <span class="s">&quot;../mailers/welcome_job&quot;</span>

<span class="k">class</span> <span class="t">WelcomeJob</span>
  <span class="k">include</span> <span class="t">Sidekiq</span><span class="t">::</span><span class="t">Worker</span>

  <span class="k">def</span> <span class="m">perform</span>(name : <span class="t">String</span>, email : <span class="t">String</span>)
    mailer <span class="o">=</span> <span class="t">WelcomeMailer</span>.<span class="k">new</span>
    mailer.deliver(name: name, email: email)
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>To execute the job, in your controller call:</p>

<pre><code class='language-crystal'><span class="t">WelcomeJob</span>.async.perform(name, email)</code></pre>

<h3>Validation</h3>

<p>Another Library included with Kemalyst is validation of your models.
You can find more details at <a href="https://github.com/drujensen/kemalyst-validators" target="_blank">Kemalyst Validators</a></p>

<h3>i18n Support</h3>

<p><a href="https://github.com/TechMagister" target="_blank">TechMagister</a> has created a HTTP::Handler that will integrate his i18n library.
You can find more details at <a href="https://github.com/TechMagister/kemalyst-i18n" target="_blank">Kemalyst i18n</a></p>

<h3>Middleware HTTP::Handlers</h3>

<p>There are 8 handlers that are pre-configured for Kemalyst.  This is similar in architecture to Rack Middleware:</p>

<ul><li>Logger - Logs all requests/responses to the logger configured.</li><li>Error - Handles any Exceptions and renders a response.</li><li>Static - Delivers any static assets from the <code>./public</code> folder.</li><li>Session - Provides a Cookie Session hash that can be accessed from the <code>context.session["key"]</code></li><li>Flash - Provides flash message hash that can be accessed from the <code>context.flash["danger"]</code></li><li>Params - Unifies the parameters into <code>context.params["key"]</code></li><li>CSRF - Helps prevent Cross Site Request Forgery.</li><li>Router - Routes requests to other handlers based on the method and path.</li></ul>

<p>Other handlers available for Kemalyst:</p>

<ul><li>CORS - Handles Cross Origin Resource Sharing.</li><li>BasicAuth - Provides Basic Authentication.</li></ul>

<p>You may want to add, replace or remove handlers based on your situation.  You can do that in the
Application configuration <code>config/application.cr</code>:</p>

<pre><code class='language-crystal'><span class="t">Kemalyst</span><span class="t">::</span><span class="t">Application</span>.config <span class="k">do</span> <span class="o">|</span>config<span class="o">|</span>
  <span class="c"># handlers will be chained in the order provided</span>
  config.handlers <span class="o">=</span> [
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Logger</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Error</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Params</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">CORS</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Router</span>.instance
  ]
<span class="k">end</span></code></pre>

<h2>Acknowledgement</h2>

<p>Kemalyst is only possible with the use and help from many other crystal projects and developers.  Special thanks to you and your contributions!</p>

<ul><li>First and foremost the <a href="https://github.com/crystal-lang/crystal/graphs/contributors" target="_blank">Crystal Team</a>.</li><li><a href="https://github.com/kemalcr/kemal" target="_blank">Kemal</a> Originally forked from here - <a href="https://github.com/sdogruyol" target="_blank">Serdar Dogruyol</a></li><li><a href="https://github.com/kemalcr/spec-kemal" target="_blank">spec-kemal</a> - Kemal Spec for easy testing  <a href="https://github.com/sdogruyol" target="_blank">Serdar Dogruyol</a></li></ul></ul>

<ul><li><a href="https://github.com/jeromegn/kilt" target="_blank">Kilt</a> Rendering templates - <a href="https://github.com/jeromegn" target="_blank">Jerome Gravel-Niquet</a></li><li><a href="https://github.com/jeromegn/slang" target="_blank">Slang</a> Slim-inspired templating language - <a href="https://github.com/jeromegn" target="_blank">Jerome Gravel-Niquet</a></li><li><a href="https://github.com/luislavena/radix" target="_blank">Radix</a> Router is mostly copied from here - <a href="https://github.com/luislavena" target="_blank">Luis Lavena</a></li><li><a href="https://github.com/raydf/smtp.cr" target="_blank">smtp.cr</a> SMTP Client for mailers - <a href="https://github.com/raydf" target="_blank">Rayner De Los Santos F.</a></li><li><a href="https://github.com/crystal-lang/crystal-db" target="_blank">crystal-db</a> Common database driver - <a href="https://github.com/bcardiff" target="_blank">Brian J. Cardiff</a></li><li><a href="https://github.com/crystal-lang/crystal-sqlite" target="_blank">crystal-sqlite</a> Sqlite Driver - <a href="https://github.com/bcardiff" target="_blank">Brian J. Cardiff</a></li><li><a href="https://github.com/crystal-lang/crystal-mysql" target="_blank">crystal-mysql</a> Mysql Driver - <a href="https://github.com/bcardiff" target="_blank">Brian J. Cardiff</a></li><li><a href="https://github.com/will/crystal-pg" target="_blank">crystal-pg</a> Postgres Driver - <a href="https://github.com/will" target="_blank">Will Leinweber</a></li><li><a href="https://github.com/mperham/sidekiq.cr" target="_blank">sidekiq.cr</a> Sidekiq - <a href="https://github.com/mperham" target="_blank">Mike Perham</a></li></ul></ul>

<p>For Kemalyst Generator</p>

<ul><li><a href="https://github.com/waterlink/mocks.cr" target="_blank">mocks</a> Mocking Library - <a href="https://github.com/waterlink" target="_blank">Oleksii Fedorov</a></li><li><a href="mosop/cli" target="_blank">Crystal CLI</a> CLI Library - <a href="https://github.com/mosop" target="_blank">mosop</a></li><li><a href="mosop/teeplate" target="_blank">Teeplate</a> Template Rendering Library - <a href="https://github.com/mosop" target="_blank">mosop</a></li><li><a href="https://github.com/greyblake/crystal-icr" target="_blank">ICR</a> Interactive Crystal - <a href="https://github.com/greyblake" target="_blank">Sergey Potapov</a></li><li><a href="https://github.com/samueleaton/sentry" target="_blank">Sentry</a> Watch files, recompile and run - <a href="https://github.com/samueleaton" target="_blank">Sam Eaton</a></li><li><a href="https://github.com/juanedi/micrate" target="_blank">Micrate</a> Rails like Migration Tool - <a href="juanedi" target="_blank">Juan Edi</a></li></ul></ul>

<h2>Contributing</h2>

<ol><li>Fork it ( https://github.com/drujensen/kemalyst/fork )</li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/drujensen" target="_blank">drujensen</a> Dru Jensen - creator, maintainer</li><li><a href="https://github.com/TechMagister" target="_blank">TechMagister</a> Arnaud Fernand√©s - contributor</li><li><a href="https://github.com/elorest" target="_blank">elorest</a> Isaac Sloan - contributor</li></ul>
</div>
</body>
</html>
